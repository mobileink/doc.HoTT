\chapter{Conformance and Behavior}

Protocols are specifications.

A correct implementation of a protocol is said to \textit{conform} to
the protocol. We say that the implementation is \textit{conformant} or
\textit{to spec}.

So conformance is a relation between an implementation and a protocol.
Formally it is a homomorphism.

Many writers appeal to metaphors of observation and behavior in
explaining coalgebras and cotypes. Not necessarily the best idea. Why
not properties? Cotypes need not ``behave''. The essetial point is
categorization: the co-ctors tell us how to recognize things in the
category. A stream object has a head property and a tail property. No
reason to think of those as behaviors and states, respectively.

For example, from: \cite{jacobs_intro_coalgebra}:

\begin{displayquote}[p. iv-v]
  Algebras are described as the duals of coalgebras (or the other
  way round), namely as maps of the form \(F (X) → X\) . One of the
  appealing aspects of this abstract view is the duality between
  structure (algebras) and behaviour (coalgebras).

  ...

  What is the essence of computing? What is the topic of the
  discipline of computer science? Answers that are often heard are
  ‘data processing’ or ‘symbol manipulation’. Here we follow a more
  behaviouristic approach and describe the subject of computer science
  as \textit{generated behaviour}.

  ...

  In abstract form, generated computer behaviour amounts to the repeated evaluation of an (inductively defined) coalgebra structure on an algebra of terms. Hence the algebras (structure) and coalgebras (behaviour) that are studied systematically in this text form the basic matter at the heart of computer science.

  ...
  A program is a structured element of the algebra that arises (as so-called initial algebra) from the programming language that is be- ing used. Each language construct corresponds to certain dynamics (behaviour), captured via a coalgebra. The program’s behaviour is thus described by a coalgebra acting on the state space of the computer. This is the view underlying the so-called structural operational semantics. Coalgebraic behaviour is generated by an algebraically structured program.

  ...

  ... the tension between what is actually inside [a block box] and
  what can be observed externally is at the heart of the theory of
  coalgebras.
\end{displayquote}


\begin{displayquote}[p. 5]
  The function \upshape{next} captures the external view on sequences:
  it tells what can be observed about a sequence σ, namely whether or
  not it is empty, and if not, what its head is. By repeated
  application of the function \upshape{next} all observable elements
  of the sequence appear. This “observational” approach is fundamental
  in coalgebra.
\end{displayquote}


\begin{displayquote}[p. 6]
  \textbf{1.2.1 Proposition} (Finality of sequences). \textit{The
    coalgebra \(\textsf{next}: \exp{A}{∞} → \{\bot\} \cup A ×
    \exp{A}{∞}\) from (1.4) is final among coalgebras of this type:
    for an arbitrary coalgebra \(c: S → \{\bot\} ∪ (A × S)\) on a set
    \(S\) there is a unique “behaviour” function \(\textrm{\upshape
      beh}_c : S → \exp{A}{∞}\) which is a homomorphism of
    coalgebras.}
\end{displayquote}

Such metaphors work well for \textit{running systems}; but those are
not the only systems we care about. In fact in software we care first
about design and implementation of systems that only then begin to
run.

So it's not really about behavior, it's about \textit{correct}
behavior. It's not about observation either, since you cannot observe
the behavior of a machine that only exists on paper. What it's about
is \textit{specification} and \textit{conformance}. And not of running
machines, but of \textit{designs}. We never try to prove the
correctness of running code; that would be an empirical endeavor.
Instead we work with the design and implementation of code, both of
which can be viewed as specifications: the former, for the program;
the latter, for the machine on which it runs.

Even lambda expressions can be viewed as specifications. Instead of
treating them as definitions that say in effect ``thus do I define
\textit{the} function corresponding to my form'', we can treat them as
specifications saying ``whatsoever conforms to me, is to be counted as
an instance of the function I describe''.



